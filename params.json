{"name":"libpbf","tagline":"File format based on Google protocol buffers. Suitable for storage of waveforms or other binned data.","body":"### Welcome to the protocol buffer file format documentation\r\n\r\nThis file format is designed for the storage of binned data, for example waveforms. Some of the key design features are: \r\n  * Simple interface for writing and reading\r\n  * Fast, dynamic compression for lightweight files\r\n  * Internal data sorting allowing parallel input\r\n  * Clean, easily extendable code\r\n\r\nThis short document should teach you all you need to know to use the class. \r\n\r\n### Installation\r\n\r\nFetch the code from github.\r\n\r\n`git clone https://github.com/coderdj/pff`\r\n\r\nThere are a few dependencies. You need the build classes (a compiler, make, etc.), as well as the protocol buffer and snappy libraries from google. On Ubuntu you can install this with:\r\n\r\n`apt-get install build-essential libsnappy-dev libprotobuf-dev`\r\n\r\nFor now you will have to re-generate the protocol buffer classes with your version of libprotobuf. At a later stage this step will be built into the build scripts. See the protoc/README.rst for more info.\r\n\r\n```\r\ncd protoc\r\nprotoc -I=./ --cpp_out=../src protocDef.proto\r\n```\r\n\r\nNow that everything's ready go the top level directory type 'make'. The library should appear in the current directory. You will have to make the library and headers find-able by your compiler in order to use it. \r\n \r\n\r\n### Writing to Files\r\n\r\nThe basic procedure for writing to files is: \r\n\r\n1. Open the file\r\n2. Open an event\r\n3. Put data into the event\r\n4. Close the event\r\n5. Go back to step 2 until you're out of data\r\n6. Close the file\r\n\r\nYou can have multiple events open at the same time. The events will be placed into an output buffer and sorted by time stamp when they are closed. Data within an event is sorted by channel number (or, optionally, by module/channel). Raw data within a channel can again be sorted by time stamp.\r\n\r\nLet's look at each step individually. The code used here is also illustrated with an example file builder in the examples directory. \r\n\r\nFirst, opening the file is done simply with the following code:\r\n\r\n```c++\r\n pff_output outfile(); \r\n int s = outfile.open_file(outputPath, outputOptions);     //outputPath and outputOptions are strings\r\n if(s!=0) cout<<\"Error opening file\"<<endl;\r\n```\r\n\r\nor, using the constructor:\r\n\r\n```c++\r\npff_output *outfile;\r\ntry{\r\n    outfile = new pff_output(outputPath, outputOptions);\r\n} \r\ncatch(...){\r\n    cout<<\"Error opening file!\"<<endl;\r\n}\r\n```\r\n\r\nThe output path provided should be a \"stub\". The program will automatically append a suffix and extension onto the file name. So if you want your data stored in a subdirectory of the current directory called \"data\" with name \"waveform\" then make this string \"data/waveform\". \r\n\r\nThe options string allows setting a few options for how the files are saved. Options are separated with a ':' character. Possible options are:\r\n* z - zip output. This compresses the data blocks internally using snappy. When reading the file again later you don't have to know if it was compressed or not. This information is stored internally.\r\n* n{int} - gives the number of events per subfile. For one measurement it might be convenient to split the data up into many sub files with, for example, 1,000 events each. Then you can set this options as 'n1000'. The data will  then be stored in files of the form: {filepath}{filenumber}.pff. Where filenumber is a 6-digit number indicating which block of 1,000 events are in the file. If you set this number so low or run so long that you exceed 999,999 files then all remaining data goes into the last file. Setting this number to zero puts all data into one file.\r\n* b{int} - sets the maximum number of events in the internal readout buffer. Best to leave this as the default (100). When the readout buffer exceeds this number, it is automatically saved to file, starting with the event with the earliest timestamp, until it is under the size again. The reason for this is to prevent memory overruns in case of user error (saving a lot of events to the buffer without writing). \r\n\r\nOnce your file is open, start adding events. You can open a new event using the following code:\r\n\r\n```c++\r\nint eventHandle=0;\r\nint success = outfile.create_event(event_timestamp, eventHandle);\r\nif(success!=0) cout<<\"Could not create event.\"<<endl;\r\n```\r\n\r\nHere timestamp lets you specify the time of the event. This is an unsigned 64-but integer. If it is set to zero the event is given the timestamp of the earliest data entry. If nothing is provided the time stamp is left at zero when the event is saved. This is not suggested, though the events will still be assigned unique ID numbers.\r\n\r\nThe event handle is passed by reference to the create_event function and is returned as a unique integer. This number will be used for adding data to this specific event in the future. This handle is valid until the event is closed. After that point it could be recycled for future events. \r\n\r\nTo add data to an event, use the add_data function. The data is a binary dump, represented by a pointer to a char array. \r\n\r\n```c++\r\nint success = outfile.add_data(eventHandle,channel,module,(char*)data,dataLength);\r\nif(success==0) cout<<\"Data added to event with handle \"<<eventHandle<<endl;\r\n```\r\n\r\nHere channel and module are integers representing the specific data channel. The module parameter is optional and can be omitted (a second add_data function exists with only 4 arguments). The dataLength is a size_t type representing the length of the data field in bytes. The eventHandle must point to an open event.\r\n\r\nIf you have a time stamp for this particular block of data, this can also be added at the end of the function call as follows:\r\n\r\n```c++\r\nint success = outfile.add_data(eventHandle,channel,module,(char*)data,dataLength,timestamp_data);\r\nif(success==0) cout<<\"Data added with time stamp \"<<timestamp_data<<endl;\r\n```\r\n\r\nThe variable timestamp_data is an unsigned 64-bit integer. Even if the data is added outside of temporal order, it will be sorted within the channel by time stamp if this field is provided.\r\n\r\nAfter all data has been added to an event, it should be closed. This is done by invoking close_event as follows.\r\n\r\n```c++\r\noutfile.close_event(eventHandle, true);\r\n```\r\n\r\nThe second argument is a Boolean telling the program if it should write the event right away. If you are writing events in temporal order, or don't care about the order, this should always be true. If events could come outside of time order and they should be sorted, set it to false (or omit the argument since false is default). The event will be stored in memory. In order to write all events stored in memory, use the write call.\r\n\r\n```c++\r\noutfile.write();\r\n```\r\n\r\nNote that this is not necessary if you have been closing events with \"true\" in the second argument. \r\n\r\nPlease note: this format is not designed to have a huge number of events in the readout buffer. It will simply store these in memory. This is really meant for events that are just slightly coming at the wrong time (1000 events or so is usually fine for sorting). \r\n\r\nTo close the file when everything is finished use:\r\n```c++\r\noutfile.close_file()\r\n```\r\n\r\n### Reading Files\r\n\r\nFiles are read in event by event. The main procedure is this:\r\n\r\n1. Open a file\r\n2. Fetch the first event\r\n3. Read all data you want from this event\r\n4. Go back to step 2 for all subsequent events\r\n5. Close the fine when done\r\n\r\nNote that you don't have to provide any attributes of the file (zipped or not, how many events per sub-file, etc.) since they are defined in the file header and automatically read.\r\n\r\nTo open a file, use the following syntax:\r\n\r\n```c++\r\npff_input infile;\r\nint success = infile.open_file(path);\r\nif (success==0) cout<<\"File opened successfully\"<<endl;\r\nelse cout<<\"File at \"<<path<<\" could not be opened.\"<<endl;\r\n```\r\n\r\nTo be continued.\r\n\r\n### Authors and Contributors\r\nWritten by Daniel Coderre (@coderdj), 2014. \r\n\r\n### Support or Contact\r\nHaving trouble? File an issue report at http://github.com/coderdj/pff.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}