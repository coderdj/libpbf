<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>libpbf by coderdj</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>libpbf</h1>
        <h2>File format based on Google protocol buffers. Suitable for storage of waveforms or other binned data.</h2>
        <a href="https://github.com/coderdj/libpbf" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h3>
<a name="welcome-to-the-protocol-buffer-file-format-documentation" class="anchor" href="#welcome-to-the-protocol-buffer-file-format-documentation"><span class="octicon octicon-link"></span></a>Welcome to the protocol buffer file format documentation</h3>

<p>This file format is designed for the storage of binned data, for example waveforms. Some of the key design features are: </p>

<ul>
<li>Simple interface for writing and reading</li>
<li>Fast, dynamic compression for lightweight files</li>
<li>Internal data sorting allowing parallel input</li>
<li>Clean, easily extendable code</li>
</ul><p>This short document should teach you all you need to know to use the class. </p>

<p><strong>Please note: this code is currently under development. Most features should function as described here, but not everything has been fully implemented or tested. If you notice something wrong, file an issue report on github.</strong> </p>

<h3>
<a name="installation" class="anchor" href="#installation"><span class="octicon octicon-link"></span></a>Installation</h3>

<p>Fetch the code from github.</p>

<p><code>git clone https://github.com/coderdj/libpbf</code></p>

<p>There are a few dependencies. You need the build classes (a compiler, make, etc.), as well as the protocol buffer and snappy libraries from google. On Ubuntu you can install this with:</p>

<p><code>apt-get install build-essential libsnappy-dev libprotobuf-dev</code></p>

<p>Note that you also need libpthread, but if you are on Ubuntu (and probably other distros) this will likely already be installed. </p>

<p>Now go the top level directory type 'make'. The library should appear in the current directory. You can install the library with 'make install'. This puts it into /usr/local/lib and the includes in /usr/local/include/pbf. If you want it somewhere else set the PREFIX variable in the Makefile.</p>

<h3>
<a name="writing-to-files" class="anchor" href="#writing-to-files"><span class="octicon octicon-link"></span></a>Writing to Files</h3>

<p>The basic procedure for writing to files is: </p>

<ol>
<li>Open the file</li>
<li>Open an event</li>
<li>Put data into the event</li>
<li>Close the event</li>
<li>Go back to step 2 until you're out of data</li>
<li>Close the file</li>
</ol><p>You can have multiple events open at the same time. The events will be placed into an output buffer and sorted by time stamp when they are closed. Data within an event is sorted by channel number (or, optionally, by module/channel). Raw data within a channel can again be sorted by time stamp.</p>

<p>Let's look at each step individually. The code used here is also illustrated with an example file builder in the examples directory. </p>

<p>First, opening the file is done simply with the following code:</p>

<div class="highlight highlight-c++"><pre> <span class="n">pff_output</span> <span class="nf">outfile</span><span class="p">();</span> 
 <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">outfile</span><span class="p">.</span><span class="n">open_file</span><span class="p">(</span><span class="n">outputPath</span><span class="p">,</span> <span class="n">outputOptions</span><span class="p">);</span>     <span class="c1">//outputPath and outputOptions are strings</span>
 <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Error opening file"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</pre></div>

<p>or, using the constructor:</p>

<div class="highlight highlight-c++"><pre><span class="n">pff_output</span> <span class="o">*</span><span class="n">outfile</span><span class="p">;</span>
<span class="n">try</span><span class="p">{</span>
    <span class="n">outfile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">pff_output</span><span class="p">(</span><span class="n">outputPath</span><span class="p">,</span> <span class="n">outputOptions</span><span class="p">);</span>
<span class="p">}</span> 
<span class="k">catch</span><span class="p">(...){</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Error opening file!"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>The output path provided should be a "stub". The program will automatically append a suffix and extension onto the file name. So if you want your data stored in a subdirectory of the current directory called "data" with name "waveform" then make this string "data/waveform". </p>

<p>The options string allows setting a few options for how the files are saved. Options are separated with a ':' character. Possible options are:</p>

<ul>
<li>z - zip output. This compresses the data blocks internally using snappy. When reading the file again later you don't have to know if it was compressed or not. This information is stored internally.</li>
<li>pz - data is already zipped. If you send compressed data to the file then you can set this option to have it flagged as compressed and automatically extracted when the file is read. Note that only snappy is supported, so if you compressed with something other than snappy do not set this option, you will have to decompress manually.</li>
<li>n{int} - gives the number of events per subfile. For one measurement it might be convenient to split the data up into many sub files with, for example, 1,000 events each. Then you can set this options as 'n1000'. The data will  then be stored in files of the form: {filepath}{filenumber}.pff. Where filenumber is a 6-digit number indicating which block of 1,000 events are in the file. If you set this number so low or run so long that you exceed 999,999 files then all remaining data goes into the last file. Setting this number to zero puts all data into one file.</li>
<li>b{int} - sets the maximum number of open events in the internal buffer. If you exceed this number of open events the library will stop assigning file handles until some events are closed. This can be useful for managing memory if you anticipate situations where you will be writing into a large number of events simultaneously. It is left as a user option since the user knows best if he wants to write into 10,000 open events with size of 1kB each or if he can only have a few open events since the events are many MB in size. The default of 100 is probably fine if this confuses you.</li>
</ul><p>Once your file is open, start adding events. You can open a new event using the following code:</p>

<div class="highlight highlight-c++"><pre><span class="kt">int</span> <span class="n">eventHandle</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">success</span> <span class="o">=</span> <span class="n">outfile</span><span class="p">.</span><span class="n">create_event</span><span class="p">(</span><span class="n">event_timestamp</span><span class="p">,</span> <span class="n">eventHandle</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">success</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Could not create event."</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</pre></div>

<p>Here timestamp lets you specify the time of the event. This is an unsigned 64-bit integer. If it is set to zero the event is given the timestamp of the earliest data entry. If nothing is provided the time stamp is left at zero when the event is saved. This is not suggested, though the events will still be assigned unique ID numbers. If you do provide timestamps then the library can sort the events by these times to read them out.</p>

<p>The event handle is passed by reference to the create_event function and is returned as a unique integer. This number will be used for adding data to this specific event in the future. This handle is valid until the event is closed. After that point it will be recycled for future events. </p>

<p>To add data to an event, use the add_data function. The data is a binary dump, represented by a pointer to a char array. Please note that the program will make a copy of this data for its own use and also remove this copy when it is finished. The user is responsible for freeing any memory allocated by his own program. It is safe to  delete or overwrite the data pointer immediately after adding the data to the event.</p>

<div class="highlight highlight-c++"><pre><span class="kt">int</span> <span class="n">success</span> <span class="o">=</span> <span class="n">outfile</span><span class="p">.</span><span class="n">add_data</span><span class="p">(</span><span class="n">eventHandle</span><span class="p">,</span><span class="n">channel</span><span class="p">,</span><span class="n">module</span><span class="p">,(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">,</span><span class="n">dataLength</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">success</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Data added to event with handle "</span><span class="o">&lt;&lt;</span><span class="n">eventHandle</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</pre></div>

<p>Here channel and module are integers representing the specific data channel. The module parameter is optional and can be omitted (a second add_data function exists with only 4 arguments). The dataLength is a size_t type representing the length of the data field in bytes. The eventHandle must point to an open event.</p>

<p>If you have a time stamp for this particular block of data, this can also be added at the end of the function call as follows:</p>

<div class="highlight highlight-c++"><pre><span class="kt">int</span> <span class="n">success</span> <span class="o">=</span> <span class="n">outfile</span><span class="p">.</span><span class="n">add_data</span><span class="p">(</span><span class="n">eventHandle</span><span class="p">,</span><span class="n">channel</span><span class="p">,</span><span class="n">module</span><span class="p">,(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">,</span><span class="n">dataLength</span><span class="p">,</span><span class="n">timestamp_data</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">success</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Data added with time stamp "</span><span class="o">&lt;&lt;</span><span class="n">timestamp_data</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</pre></div>

<p>The variable timestamp_data is an unsigned 64-bit integer. Even if the data is added outside of temporal order, it will be sorted within the channel by time stamp if this field is provided. This way when the file is read it will be read in time order.</p>

<p>After all data has been added to an event, it should be closed. This is done by invoking close_event as follows.</p>

<div class="highlight highlight-c++"><pre><span class="n">outfile</span><span class="p">.</span><span class="n">close_event</span><span class="p">(</span><span class="n">eventHandle</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</pre></div>

<p>The second argument is a Boolean telling the program if it should write the event right away. If your events are pre-sorted or if you don't care about the order this can always be true. If events could come outside of time order and they should be sorted, set it to false (or omit the argument since false is default). The event will be stored in memory. In order to write all events stored in memory, use the write call.</p>

<div class="highlight highlight-c++"><pre><span class="n">outfile</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>
</pre></div>

<p>The write call can also optionally take a 64-bit integer as an argument. This is a timestamp and will tell the program to write all events up to this timestamp to file. Please note that the internal buffer will blow up in size if the user does not call write. If the buffer gets too large the program will stop reading new events in until it is written out. </p>

<p>Note that calling write is not necessary if you have always been closing events with "true" in the second argument. </p>

<p>To close the file when everything is finished use:</p>

<div class="highlight highlight-c++"><pre><span class="n">outfile</span><span class="p">.</span><span class="n">close_file</span><span class="p">()</span>
</pre></div>

<h3>
<a name="reading-files" class="anchor" href="#reading-files"><span class="octicon octicon-link"></span></a>Reading Files</h3>

<p>Files are read in event by event. The main procedure is this:</p>

<ol>
<li>Open a file</li>
<li>Fetch the first event</li>
<li>Read all data you want from this event</li>
<li>Go back to step 2 for all subsequent events</li>
<li>Close the fine when done</li>
</ol><p>Note that you don't have to provide any attributes of the file (zipped or not, how many events per sub-file, etc.) since they are defined in the file header and automatically read.</p>

<p>To open a file, use the following syntax:</p>

<div class="highlight highlight-c++"><pre><span class="n">pff_input</span> <span class="n">infile</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">success</span> <span class="o">=</span> <span class="n">infile</span><span class="p">.</span><span class="n">open_file</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"File opened successfully"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="k">else</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"File at "</span><span class="o">&lt;&lt;</span><span class="n">path</span><span class="o">&lt;&lt;</span><span class="s">" could not be opened."</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</pre></div>

<p>Files are read from start to finish in order. The way it works is that the pff_input object is told to look at an event. The event is unpacked and stored in memory. Then all data from that event can be accessed as needed (in any order and multiple times if desired). After that the user tells the object to go to a different event (either the next event or an event with a given ID). </p>

<p>A loop where events are accessed in order might look like this:</p>

<div class="highlight highlight-c++"><pre><span class="n">pff_intput</span> <span class="n">infile</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">infile</span><span class="p">.</span><span class="n">open_file</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
<span class="k">while</span><span class="p">(</span><span class="n">infile</span><span class="p">.</span><span class="n">get_next_event</span><span class="p">()){</span>
<span class="c1">//do some stuff</span>
<span class="c1">//</span>
<span class="p">}</span>
</pre></div>

<p>On the other hand, a specific event can be accessed as follows:</p>

<div class="highlight highlight-c++"><pre><span class="k">if</span><span class="p">(</span><span class="n">infile</span><span class="p">.</span><span class="n">get_event</span><span class="p">(</span><span class="n">eventID</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Event id "</span><span class="o">&lt;&lt;</span><span class="n">eventID</span><span class="o">&lt;&lt;</span><span class="s">" does not exist."</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</pre></div>

<p>Here eventID is a long long int. Note that the event IDs must be accessed in order as the file will be scanned from start to finish. If the event ID is not found then the file probably scanned to the end and should be closed and reopened. </p>

<p>Data within an event is organized by channels. To loop through all channels and pull data from them, use something like the following:</p>

<div class="highlight highlight-c++"><pre><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">channel</span><span class="o">&lt;</span><span class="n">infile</span><span class="p">.</span><span class="n">num_channels</span><span class="p">();</span> <span class="n">channel</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
     <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">datasize</span><span class="p">;</span>
     <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">datatime</span><span class="p">;</span>
     <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">dataindex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dataindex</span><span class="o">&lt;</span><span class="n">infile</span><span class="p">.</span><span class="n">num_data</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span> <span class="n">dataindex</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">infile</span><span class="p">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span><span class="n">dataindex</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">datasize</span><span class="p">,</span><span class="n">datatime</span><span class="p">);</span>
          <span class="c1">//process data</span>
     <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>The data can also be accessed by module/channel ID. Additionally, other functions exist for accessing metadata for the event or out of the file header. See the pbf_input.hh file for a full list of functionality.</p>

<p>When you are done reading a file, it's a good idea to close it again. This is done simply by:</p>

<div class="highlight highlight-c++"><pre><span class="n">infile</span><span class="p">.</span><span class="n">close_file</span><span class="p">();</span>
</pre></div>

<p>Please note that the data blocks accessed in this was are identical to what you put in. Any packing done by the file format will be reversed when the data is returned. For example if you provide unzipped data and asked pff_output to compress it, it will be automatically decompressed and returned unzipped. </p>

<p>A full example of reading from files and plotting the resulting data is given in examples/WaveformViewer. This example requires the ROOT software package from CERN (<a href="http://root.cern.ch">http://root.cern.ch</a>). In the example, the stored data are waveforms where the binary dump is a series of 16-bit (2 byte) samples. </p>

<h3>
<a name="authors-and-contributors" class="anchor" href="#authors-and-contributors"><span class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p>Written by Daniel Coderre (<a href="https://github.com/coderdj" class="user-mention">@coderdj</a>), 2014. </p>

<h3>
<a name="support-or-contact" class="anchor" href="#support-or-contact"><span class="octicon octicon-link"></span></a>Support or Contact</h3>

<p>Having trouble? File an issue report at <a href="http://github.com/coderdj/libpbf">http://github.com/coderdj/libpbf</a>. Want to help? Contact me on github (<a href="https://github.com/coderdj" class="user-mention">@coderdj</a>). Want to buy me a beer? Come visit Bern.</p>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/coderdj/libpbf/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/coderdj/libpbf/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/coderdj/libpbf"></a> is maintained by <a href="https://github.com/coderdj">coderdj</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>