<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>libpff by coderdj</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>libpff</h1>
        <h2>File format based on Google protocol buffers. Suitable for storage of waveforms or other binned data.</h2>
        <a href="https://github.com/coderdj/pff" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h3>
<a name="welcome-to-the-protocol-buffer-file-format-documentation" class="anchor" href="#welcome-to-the-protocol-buffer-file-format-documentation"><span class="octicon octicon-link"></span></a>Welcome to the protocol buffer file format documentation</h3>

<p>This file format is designed for the storage of binned data, for example waveforms. Some of the key design features are: </p>

<ul>
<li>Simple interface for writing and reading</li>
<li>Fast, dynamic compression for lightweight files</li>
<li>Internal data sorting allowing parallel input</li>
<li>Clean, easily extendable code</li>
</ul><p>This short document should teach you all you need to know to use the class. </p>

<h3>
<a name="installation" class="anchor" href="#installation"><span class="octicon octicon-link"></span></a>Installation</h3>

<p>Fetch the code from github.</p>

<p><code>git clone https://github.com/coderdj/pff</code></p>

<p>There are a few dependencies. You need the build classes (a compiler, make, etc.), as well as the protocol buffer and snappy libraries from google. On Ubuntu you can install this with:</p>

<p><code>apt-get install build-essential libsnappy-dev libprotobuf-dev</code></p>

<p>For now you will have to re-generate the protocol buffer classes with your version of libprotobuf. At a later stage this step will be built into the build scripts. See the protoc/README.rst for more info.</p>

<pre><code>cd protoc
protoc -I=./ --cpp_out=../src protocDef.proto
</code></pre>

<p>Now that everything's ready go the top level directory type 'make'. The library should appear in the current directory. You will have to make the library and headers find-able by your compiler in order to use it. </p>

<h3>
<a name="writing-to-files" class="anchor" href="#writing-to-files"><span class="octicon octicon-link"></span></a>Writing to Files</h3>

<p>The basic procedure for writing to files is: </p>

<ol>
<li>Open the file</li>
<li>Open an event</li>
<li>Put data into the event</li>
<li>Close the event</li>
<li>Go back to step 2 until you're out of data</li>
<li>Close the file</li>
</ol><p>You can have multiple events open at the same time. The events will be placed into an output buffer and sorted by time stamp when they are closed. Data within an event is sorted by channel number (or, optionally, by module/channel). Raw data within a channel can again be sorted by time stamp.</p>

<p>Let's look at each step individually. The code used here is also illustrated with an example file builder in the examples directory. </p>

<p>First, opening the file is done simply with the following code:</p>

<div class="highlight highlight-c++"><pre> <span class="n">pff_output</span> <span class="nf">outfile</span><span class="p">();</span> 
 <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">outfile</span><span class="p">.</span><span class="n">open_file</span><span class="p">(</span><span class="n">outputPath</span><span class="p">,</span> <span class="n">outputOptions</span><span class="p">);</span>     <span class="c1">//outputPath and outputOptions are strings</span>
 <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Error opening file"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</pre></div>

<p>or, using the constructor:</p>

<div class="highlight highlight-c++"><pre><span class="n">pff_output</span> <span class="o">*</span><span class="n">outfile</span><span class="p">;</span>
<span class="n">try</span><span class="p">{</span>
    <span class="n">outfile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">pff_output</span><span class="p">(</span><span class="n">outputPath</span><span class="p">,</span> <span class="n">outputOptions</span><span class="p">);</span>
<span class="p">}</span> 
<span class="k">catch</span><span class="p">(...){</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Error opening file!"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>The output path provided should be a "stub". The program will automatically append a suffix and extension onto the file name. So if you want your data stored in a subdirectory of the current directory called "data" with name "waveform" then make this string "data/waveform". </p>

<p>The options string allows setting a few options for how the files are saved. Options are separated with a ':' character. Possible options are:</p>

<ul>
<li>z - zip output. This compresses the data blocks internally using snappy. When reading the file again later you don't have to know if it was compressed or not. This information is stored internally.</li>
<li>n{int} - gives the number of events per subfile. For one measurement it might be convenient to split the data up into many sub files with, for example, 1,000 events each. Then you can set this options as 'n1000'. The data will  then be stored in files of the form: {filepath}{filenumber}.pff. Where filenumber is a 6-digit number indicating which block of 1,000 events are in the file. If you set this number so low or run so long that you exceed 999,999 files then all remaining data goes into the last file. Setting this number to zero puts all data into one file.</li>
<li>b{int} - sets the maximum number of events in the internal readout buffer. Best to leave this as the default (100). When the readout buffer exceeds this number, it is automatically saved to file, starting with the event with the earliest timestamp, until it is under the size again. The reason for this is to prevent memory overruns in case of user error (saving a lot of events to the buffer without writing). </li>
</ul><p>Once your file is open, start adding events. You can open a new event using the following code:</p>

<div class="highlight highlight-c++"><pre><span class="kt">int</span> <span class="n">eventHandle</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">success</span> <span class="o">=</span> <span class="n">outfile</span><span class="p">.</span><span class="n">create_event</span><span class="p">(</span><span class="n">event_timestamp</span><span class="p">,</span> <span class="n">eventHandle</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">success</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Could not create event."</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</pre></div>

<p>Here timestamp lets you specify the time of the event. This is an unsigned 64-but integer. If it is set to zero the event is given the timestamp of the earliest data entry. If nothing is provided the time stamp is left at zero when the event is saved. This is not suggested, though the events will still be assigned unique ID numbers.</p>

<p>The event handle is passed by reference to the create_event function and is returned as a unique integer. This number will be used for adding data to this specific event in the future. This handle is valid until the event is closed. After that point it could be recycled for future events. </p>

<p>To add data to an event, use the add_data function. The data is a binary dump, represented by a pointer to a char array. </p>

<div class="highlight highlight-c++"><pre><span class="kt">int</span> <span class="n">success</span> <span class="o">=</span> <span class="n">outfile</span><span class="p">.</span><span class="n">add_data</span><span class="p">(</span><span class="n">eventHandle</span><span class="p">,</span><span class="n">channel</span><span class="p">,</span><span class="n">module</span><span class="p">,(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">,</span><span class="n">dataLength</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">success</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Data added to event with handle "</span><span class="o">&lt;&lt;</span><span class="n">eventHandle</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</pre></div>

<p>Here channel and module are integers representing the specific data channel. The module parameter is optional and can be omitted (a second add_data function exists with only 4 arguments). The dataLength is a size_t type representing the length of the data field in bytes. The eventHandle must point to an open event.</p>

<p>If you have a time stamp for this particular block of data, this can also be added at the end of the function call as follows:</p>

<div class="highlight highlight-c++"><pre><span class="kt">int</span> <span class="n">success</span> <span class="o">=</span> <span class="n">outfile</span><span class="p">.</span><span class="n">add_data</span><span class="p">(</span><span class="n">eventHandle</span><span class="p">,</span><span class="n">channel</span><span class="p">,</span><span class="n">module</span><span class="p">,(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">,</span><span class="n">dataLength</span><span class="p">,</span><span class="n">timestamp_data</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">success</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"Data added with time stamp "</span><span class="o">&lt;&lt;</span><span class="n">timestamp_data</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</pre></div>

<p>The variable timestamp_data is an unsigned 64-bit integer. Even if the data is added outside of temporal order, it will be sorted within the channel by time stamp if this field is provided.</p>

<p>After all data has been added to an event, it should be closed. This is done by invoking close_event as follows.</p>

<div class="highlight highlight-c++"><pre><span class="n">outfile</span><span class="p">.</span><span class="n">close_event</span><span class="p">(</span><span class="n">eventHandle</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</pre></div>

<p>The second argument is a Boolean telling the program if it should write the event right away. If you are writing events in temporal order, or don't care about the order, this should always be true. If events could come outside of time order and they should be sorted, set it to false (or omit the argument since false is default). The event will be stored in memory. In order to write all events stored in memory, use the write call.</p>

<div class="highlight highlight-c++"><pre><span class="n">outfile</span><span class="p">.</span><span class="n">write</span><span class="p">();</span>
</pre></div>

<p>Note that this is not necessary if you have been closing events with "true" in the second argument. </p>

<p>Please note: this format is not designed to have a huge number of events in the readout buffer. It will simply store these in memory. This is really meant for events that are just slightly coming at the wrong time (1000 events or so is usually fine for sorting). </p>

<p>To close the file when everything is finished use:</p>

<div class="highlight highlight-c++"><pre><span class="n">outfile</span><span class="p">.</span><span class="n">close_file</span><span class="p">()</span>
</pre></div>

<h3>
<a name="reading-files" class="anchor" href="#reading-files"><span class="octicon octicon-link"></span></a>Reading Files</h3>

<p>Coming soon! Probably important, huh.</p>

<h3>
<a name="authors-and-contributors" class="anchor" href="#authors-and-contributors"><span class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p>Written by Daniel Coderre (<a href="https://github.com/coderdj" class="user-mention">@coderdj</a>), 2014. </p>

<h3>
<a name="support-or-contact" class="anchor" href="#support-or-contact"><span class="octicon octicon-link"></span></a>Support or Contact</h3>

<p>Having trouble? File an issue report at <a href="http://github.com/coderdj/pff">http://github.com/coderdj/pff</a>.</p>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/coderdj/pff/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/coderdj/pff/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/coderdj/pff"></a> is maintained by <a href="https://github.com/coderdj">coderdj</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>